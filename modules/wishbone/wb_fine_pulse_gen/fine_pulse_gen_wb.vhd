---------------------------------------------------------------------------------------
-- Title          : Wishbone slave core for Generic Fine Pulse Generator Unit
---------------------------------------------------------------------------------------
-- File           : fine_pulse_gen_wb.vhd
-- Author         : auto-generated by wbgen2 from fine_pulse_gen_wb.wb
-- Created        : Tue Mar 31 17:24:02 2020
-- Standard       : VHDL'87
---------------------------------------------------------------------------------------
-- THIS FILE WAS GENERATED BY wbgen2 FROM SOURCE FILE fine_pulse_gen_wb.wb
-- DO NOT HAND-EDIT UNLESS IT'S ABSOLUTELY NECESSARY!
---------------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.wishbone_pkg.all;

use work.fpg_wbgen2_pkg.all;


entity fine_pulse_gen_wb is
port (
  rst_n_i                                  : in     std_logic;
  clk_sys_i                                : in     std_logic;
  clk_ref_i                                : in     std_logic;
  clk_odelay_i                             : in     std_logic;
  slave_i                                  : in     t_wishbone_slave_in;
  slave_o                                  : out    t_wishbone_slave_out;
  int_o                                    : out    std_logic;
  regs_i                                   : in     t_fpg_in_registers;
  regs_o                                   : out    t_fpg_out_registers
);
end fine_pulse_gen_wb;

architecture syn of fine_pulse_gen_wb is

signal fpg_csr_trig0_dly0                       : std_logic      ;
signal fpg_csr_trig0_int                        : std_logic      ;
signal fpg_csr_trig1_dly0                       : std_logic      ;
signal fpg_csr_trig1_int                        : std_logic      ;
signal fpg_csr_trig2_dly0                       : std_logic      ;
signal fpg_csr_trig2_int                        : std_logic      ;
signal fpg_csr_trig3_dly0                       : std_logic      ;
signal fpg_csr_trig3_int                        : std_logic      ;
signal fpg_csr_trig4_dly0                       : std_logic      ;
signal fpg_csr_trig4_int                        : std_logic      ;
signal fpg_csr_trig5_dly0                       : std_logic      ;
signal fpg_csr_trig5_int                        : std_logic      ;
signal fpg_csr_trig6_dly0                       : std_logic      ;
signal fpg_csr_trig6_int                        : std_logic      ;
signal fpg_csr_trig7_dly0                       : std_logic      ;
signal fpg_csr_trig7_int                        : std_logic      ;
signal fpg_csr_force0_dly0                      : std_logic      ;
signal fpg_csr_force0_int                       : std_logic      ;
signal fpg_csr_force1_dly0                      : std_logic      ;
signal fpg_csr_force1_int                       : std_logic      ;
signal fpg_csr_force2_dly0                      : std_logic      ;
signal fpg_csr_force2_int                       : std_logic      ;
signal fpg_csr_force3_dly0                      : std_logic      ;
signal fpg_csr_force3_int                       : std_logic      ;
signal fpg_csr_force4_dly0                      : std_logic      ;
signal fpg_csr_force4_int                       : std_logic      ;
signal fpg_csr_force5_dly0                      : std_logic      ;
signal fpg_csr_force5_int                       : std_logic      ;
signal fpg_csr_ready_int                        : std_logic_vector(5 downto 0);
signal fpg_csr_ready_lwb                        : std_logic      ;
signal fpg_csr_ready_lwb_delay                  : std_logic      ;
signal fpg_csr_ready_lwb_in_progress            : std_logic      ;
signal fpg_csr_ready_lwb_s0                     : std_logic      ;
signal fpg_csr_ready_lwb_s1                     : std_logic      ;
signal fpg_csr_ready_lwb_s2                     : std_logic      ;
signal fpg_csr_pll_rst_int                      : std_logic      ;
signal fpg_ocr0_pps_offs_int                    : std_logic_vector(3 downto 0);
signal fpg_ocr0_fine_int                        : std_logic_vector(4 downto 0);
signal fpg_ocr0_pol_int                         : std_logic      ;
signal fpg_ocr0_mask_int                        : std_logic_vector(7 downto 0);
signal fpg_ocr0_cont_int                        : std_logic      ;
signal fpg_ocr0_trig_sel_int                    : std_logic      ;
signal fpg_ocr1_pps_offs_int                    : std_logic_vector(3 downto 0);
signal fpg_ocr1_fine_int                        : std_logic_vector(4 downto 0);
signal fpg_ocr1_pol_int                         : std_logic      ;
signal fpg_ocr1_mask_int                        : std_logic_vector(7 downto 0);
signal fpg_ocr1_cont_int                        : std_logic      ;
signal fpg_ocr1_trig_sel_int                    : std_logic      ;
signal fpg_ocr2_pps_offs_int                    : std_logic_vector(3 downto 0);
signal fpg_ocr2_fine_int                        : std_logic_vector(4 downto 0);
signal fpg_ocr2_pol_int                         : std_logic      ;
signal fpg_ocr2_mask_int                        : std_logic_vector(7 downto 0);
signal fpg_ocr2_cont_int                        : std_logic      ;
signal fpg_ocr2_trig_sel_int                    : std_logic      ;
signal fpg_ocr3_pps_offs_int                    : std_logic_vector(3 downto 0);
signal fpg_ocr3_fine_int                        : std_logic_vector(4 downto 0);
signal fpg_ocr3_pol_int                         : std_logic      ;
signal fpg_ocr3_mask_int                        : std_logic_vector(7 downto 0);
signal fpg_ocr3_cont_int                        : std_logic      ;
signal fpg_ocr3_trig_sel_int                    : std_logic      ;
signal fpg_ocr4_pps_offs_int                    : std_logic_vector(3 downto 0);
signal fpg_ocr4_fine_int                        : std_logic_vector(4 downto 0);
signal fpg_ocr4_pol_int                         : std_logic      ;
signal fpg_ocr4_mask_int                        : std_logic_vector(7 downto 0);
signal fpg_ocr4_cont_int                        : std_logic      ;
signal fpg_ocr4_trig_sel_int                    : std_logic      ;
signal fpg_ocr5_pps_offs_int                    : std_logic_vector(3 downto 0);
signal fpg_ocr5_fine_int                        : std_logic_vector(4 downto 0);
signal fpg_ocr5_pol_int                         : std_logic      ;
signal fpg_ocr5_mask_int                        : std_logic_vector(7 downto 0);
signal fpg_ocr5_cont_int                        : std_logic      ;
signal fpg_ocr5_trig_sel_int                    : std_logic      ;
signal fpg_ocr6_pps_offs_int                    : std_logic_vector(3 downto 0);
signal fpg_ocr6_fine_int                        : std_logic_vector(4 downto 0);
signal fpg_ocr6_pol_int                         : std_logic      ;
signal fpg_ocr6_mask_int                        : std_logic_vector(7 downto 0);
signal fpg_ocr6_cont_int                        : std_logic      ;
signal fpg_ocr6_trig_sel_int                    : std_logic      ;
signal fpg_ocr7_pps_offs_int                    : std_logic_vector(3 downto 0);
signal fpg_ocr7_fine_int                        : std_logic_vector(4 downto 0);
signal fpg_ocr7_pol_int                         : std_logic      ;
signal fpg_ocr7_mask_int                        : std_logic_vector(7 downto 0);
signal fpg_ocr7_cont_int                        : std_logic      ;
signal fpg_ocr7_trig_sel_int                    : std_logic      ;
signal fpg_odelay_calib_rst_idelayctrl_int      : std_logic      ;
signal fpg_odelay_calib_rst_idelayctrl_sync0    : std_logic      ;
signal fpg_odelay_calib_rst_idelayctrl_sync1    : std_logic      ;
signal fpg_odelay_calib_rst_odelay_int          : std_logic      ;
signal fpg_odelay_calib_rst_odelay_sync0        : std_logic      ;
signal fpg_odelay_calib_rst_odelay_sync1        : std_logic      ;
signal fpg_odelay_calib_rst_oserdes_int         : std_logic      ;
signal fpg_odelay_calib_rst_oserdes_sync0       : std_logic      ;
signal fpg_odelay_calib_rst_oserdes_sync1       : std_logic      ;
signal fpg_odelay_calib_rdy_sync0               : std_logic      ;
signal fpg_odelay_calib_rdy_sync1               : std_logic      ;
signal fpg_odelay_calib_value_int               : std_logic_vector(8 downto 0);
signal fpg_odelay_calib_value_swb               : std_logic      ;
signal fpg_odelay_calib_value_swb_delay         : std_logic      ;
signal fpg_odelay_calib_value_swb_s0            : std_logic      ;
signal fpg_odelay_calib_value_swb_s1            : std_logic      ;
signal fpg_odelay_calib_value_swb_s2            : std_logic      ;
signal fpg_odelay_calib_value_update_int        : std_logic      ;
signal fpg_odelay_calib_value_update_int_delay  : std_logic      ;
signal fpg_odelay_calib_value_update_sync0      : std_logic      ;
signal fpg_odelay_calib_value_update_sync1      : std_logic      ;
signal fpg_odelay_calib_value_update_sync2      : std_logic      ;
signal fpg_odelay_calib_bitslip_int             : std_logic_vector(1 downto 0);
signal fpg_odelay_calib_bitslip_swb             : std_logic      ;
signal fpg_odelay_calib_bitslip_swb_delay       : std_logic      ;
signal fpg_odelay_calib_bitslip_swb_s0          : std_logic      ;
signal fpg_odelay_calib_bitslip_swb_s1          : std_logic      ;
signal fpg_odelay_calib_bitslip_swb_s2          : std_logic      ;
signal fpg_odelay_calib_en_vtc_int              : std_logic      ;
signal fpg_odelay_calib_en_vtc_sync0            : std_logic      ;
signal fpg_odelay_calib_en_vtc_sync1            : std_logic      ;
signal fpg_odelay_calib_cal_latch_int           : std_logic      ;
signal fpg_odelay_calib_cal_latch_int_delay     : std_logic      ;
signal fpg_odelay_calib_cal_latch_sync0         : std_logic      ;
signal fpg_odelay_calib_cal_latch_sync1         : std_logic      ;
signal fpg_odelay_calib_cal_latch_sync2         : std_logic      ;
signal fpg_odelay_calib_taps_int                : std_logic_vector(8 downto 0);
signal fpg_odelay_calib_taps_lwb                : std_logic      ;
signal fpg_odelay_calib_taps_lwb_delay          : std_logic      ;
signal fpg_odelay_calib_taps_lwb_in_progress    : std_logic      ;
signal fpg_odelay_calib_taps_lwb_s0             : std_logic      ;
signal fpg_odelay_calib_taps_lwb_s1             : std_logic      ;
signal fpg_odelay_calib_taps_lwb_s2             : std_logic      ;
signal ack_sreg                                 : std_logic_vector(9 downto 0);
signal rddata_reg                               : std_logic_vector(31 downto 0);
signal wrdata_reg                               : std_logic_vector(31 downto 0);
signal bwsel_reg                                : std_logic_vector(3 downto 0);
signal rwaddr_reg                               : std_logic_vector(3 downto 0);
signal ack_in_progress                          : std_logic      ;
signal wr_int                                   : std_logic      ;
signal rd_int                                   : std_logic      ;
signal allones                                  : std_logic_vector(31 downto 0);
signal allzeros                                 : std_logic_vector(31 downto 0);

begin
-- Some internal signals assignments
wrdata_reg <= slave_i.dat;
-- 
-- Main register bank access process.
process (clk_sys_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    ack_sreg <= "0000000000";
    ack_in_progress <= '0';
    rddata_reg <= "00000000000000000000000000000000";
    fpg_csr_trig0_int <= '0';
    fpg_csr_trig1_int <= '0';
    fpg_csr_trig2_int <= '0';
    fpg_csr_trig3_int <= '0';
    fpg_csr_trig4_int <= '0';
    fpg_csr_trig5_int <= '0';
    fpg_csr_trig6_int <= '0';
    fpg_csr_trig7_int <= '0';
    fpg_csr_force0_int <= '0';
    fpg_csr_force1_int <= '0';
    fpg_csr_force2_int <= '0';
    fpg_csr_force3_int <= '0';
    fpg_csr_force4_int <= '0';
    fpg_csr_force5_int <= '0';
    fpg_csr_ready_lwb <= '0';
    fpg_csr_ready_lwb_delay <= '0';
    fpg_csr_ready_lwb_in_progress <= '0';
    fpg_csr_pll_rst_int <= '0';
    fpg_ocr0_pps_offs_int <= "0000";
    fpg_ocr0_fine_int <= "00000";
    fpg_ocr0_pol_int <= '0';
    fpg_ocr0_mask_int <= "00000000";
    fpg_ocr0_cont_int <= '0';
    fpg_ocr0_trig_sel_int <= '0';
    fpg_ocr1_pps_offs_int <= "0000";
    fpg_ocr1_fine_int <= "00000";
    fpg_ocr1_pol_int <= '0';
    fpg_ocr1_mask_int <= "00000000";
    fpg_ocr1_cont_int <= '0';
    fpg_ocr1_trig_sel_int <= '0';
    fpg_ocr2_pps_offs_int <= "0000";
    fpg_ocr2_fine_int <= "00000";
    fpg_ocr2_pol_int <= '0';
    fpg_ocr2_mask_int <= "00000000";
    fpg_ocr2_cont_int <= '0';
    fpg_ocr2_trig_sel_int <= '0';
    fpg_ocr3_pps_offs_int <= "0000";
    fpg_ocr3_fine_int <= "00000";
    fpg_ocr3_pol_int <= '0';
    fpg_ocr3_mask_int <= "00000000";
    fpg_ocr3_cont_int <= '0';
    fpg_ocr3_trig_sel_int <= '0';
    fpg_ocr4_pps_offs_int <= "0000";
    fpg_ocr4_fine_int <= "00000";
    fpg_ocr4_pol_int <= '0';
    fpg_ocr4_mask_int <= "00000000";
    fpg_ocr4_cont_int <= '0';
    fpg_ocr4_trig_sel_int <= '0';
    fpg_ocr5_pps_offs_int <= "0000";
    fpg_ocr5_fine_int <= "00000";
    fpg_ocr5_pol_int <= '0';
    fpg_ocr5_mask_int <= "00000000";
    fpg_ocr5_cont_int <= '0';
    fpg_ocr5_trig_sel_int <= '0';
    fpg_ocr6_pps_offs_int <= "0000";
    fpg_ocr6_fine_int <= "00000";
    fpg_ocr6_pol_int <= '0';
    fpg_ocr6_mask_int <= "00000000";
    fpg_ocr6_cont_int <= '0';
    fpg_ocr6_trig_sel_int <= '0';
    fpg_ocr7_pps_offs_int <= "0000";
    fpg_ocr7_fine_int <= "00000";
    fpg_ocr7_pol_int <= '0';
    fpg_ocr7_mask_int <= "00000000";
    fpg_ocr7_cont_int <= '0';
    fpg_ocr7_trig_sel_int <= '0';
    fpg_odelay_calib_rst_idelayctrl_int <= '0';
    fpg_odelay_calib_rst_odelay_int <= '0';
    fpg_odelay_calib_rst_oserdes_int <= '0';
    fpg_odelay_calib_value_int <= "000000000";
    fpg_odelay_calib_value_swb <= '0';
    fpg_odelay_calib_value_swb_delay <= '0';
    fpg_odelay_calib_value_update_int <= '0';
    fpg_odelay_calib_value_update_int_delay <= '0';
    fpg_odelay_calib_bitslip_int <= "00";
    fpg_odelay_calib_bitslip_swb <= '0';
    fpg_odelay_calib_bitslip_swb_delay <= '0';
    fpg_odelay_calib_en_vtc_int <= '0';
    fpg_odelay_calib_cal_latch_int <= '0';
    fpg_odelay_calib_cal_latch_int_delay <= '0';
    fpg_odelay_calib_taps_lwb <= '0';
    fpg_odelay_calib_taps_lwb_delay <= '0';
    fpg_odelay_calib_taps_lwb_in_progress <= '0';
  elsif rising_edge(clk_sys_i) then
-- advance the ACK generator shift register
    ack_sreg(8 downto 0) <= ack_sreg(9 downto 1);
    ack_sreg(9) <= '0';
    if (ack_in_progress = '1') then
      if (ack_sreg(0) = '1') then
        fpg_csr_trig0_int <= '0';
        fpg_csr_trig1_int <= '0';
        fpg_csr_trig2_int <= '0';
        fpg_csr_trig3_int <= '0';
        fpg_csr_trig4_int <= '0';
        fpg_csr_trig5_int <= '0';
        fpg_csr_trig6_int <= '0';
        fpg_csr_trig7_int <= '0';
        fpg_csr_force0_int <= '0';
        fpg_csr_force1_int <= '0';
        fpg_csr_force2_int <= '0';
        fpg_csr_force3_int <= '0';
        fpg_csr_force4_int <= '0';
        fpg_csr_force5_int <= '0';
        ack_in_progress <= '0';
      else
        fpg_csr_ready_lwb <= fpg_csr_ready_lwb_delay;
        fpg_csr_ready_lwb_delay <= '0';
        if ((ack_sreg(1) = '1') and (fpg_csr_ready_lwb_in_progress = '1')) then
          rddata_reg(19 downto 14) <= fpg_csr_ready_int;
          fpg_csr_ready_lwb_in_progress <= '0';
        end if;
        fpg_odelay_calib_value_swb <= fpg_odelay_calib_value_swb_delay;
        fpg_odelay_calib_value_swb_delay <= '0';
        fpg_odelay_calib_value_update_int <= fpg_odelay_calib_value_update_int_delay;
        fpg_odelay_calib_value_update_int_delay <= '0';
        fpg_odelay_calib_bitslip_swb <= fpg_odelay_calib_bitslip_swb_delay;
        fpg_odelay_calib_bitslip_swb_delay <= '0';
        fpg_odelay_calib_cal_latch_int <= fpg_odelay_calib_cal_latch_int_delay;
        fpg_odelay_calib_cal_latch_int_delay <= '0';
        fpg_odelay_calib_taps_lwb <= fpg_odelay_calib_taps_lwb_delay;
        fpg_odelay_calib_taps_lwb_delay <= '0';
        if ((ack_sreg(1) = '1') and (fpg_odelay_calib_taps_lwb_in_progress = '1')) then
          rddata_reg(26 downto 18) <= fpg_odelay_calib_taps_int;
          fpg_odelay_calib_taps_lwb_in_progress <= '0';
        end if;
      end if;
    else
      if ((slave_i.cyc = '1') and (slave_i.stb = '1')) then
        case rwaddr_reg(3 downto 0) is
        when "0000" => 
          if (slave_i.we = '1') then
            fpg_csr_trig0_int <= wrdata_reg(0);
            fpg_csr_trig1_int <= wrdata_reg(1);
            fpg_csr_trig2_int <= wrdata_reg(2);
            fpg_csr_trig3_int <= wrdata_reg(3);
            fpg_csr_trig4_int <= wrdata_reg(4);
            fpg_csr_trig5_int <= wrdata_reg(5);
            fpg_csr_trig6_int <= wrdata_reg(6);
            fpg_csr_trig7_int <= wrdata_reg(7);
            fpg_csr_force0_int <= wrdata_reg(8);
            fpg_csr_force1_int <= wrdata_reg(9);
            fpg_csr_force2_int <= wrdata_reg(10);
            fpg_csr_force3_int <= wrdata_reg(11);
            fpg_csr_force4_int <= wrdata_reg(12);
            fpg_csr_force5_int <= wrdata_reg(13);
            fpg_csr_pll_rst_int <= wrdata_reg(20);
          end if;
          rddata_reg(0) <= '0';
          rddata_reg(1) <= '0';
          rddata_reg(2) <= '0';
          rddata_reg(3) <= '0';
          rddata_reg(4) <= '0';
          rddata_reg(5) <= '0';
          rddata_reg(6) <= '0';
          rddata_reg(7) <= '0';
          rddata_reg(8) <= '0';
          rddata_reg(9) <= '0';
          rddata_reg(10) <= '0';
          rddata_reg(11) <= '0';
          rddata_reg(12) <= '0';
          rddata_reg(13) <= '0';
          if (slave_i.we = '0') then
            fpg_csr_ready_lwb <= '1';
            fpg_csr_ready_lwb_delay <= '1';
            fpg_csr_ready_lwb_in_progress <= '1';
          end if;
          rddata_reg(20) <= fpg_csr_pll_rst_int;
          rddata_reg(21) <= 'X';
          rddata_reg(22) <= 'X';
          rddata_reg(23) <= 'X';
          rddata_reg(24) <= 'X';
          rddata_reg(25) <= 'X';
          rddata_reg(26) <= 'X';
          rddata_reg(27) <= 'X';
          rddata_reg(28) <= 'X';
          rddata_reg(29) <= 'X';
          rddata_reg(30) <= 'X';
          rddata_reg(31) <= 'X';
          ack_sreg(5) <= '1';
          ack_in_progress <= '1';
        when "0001" => 
          if (slave_i.we = '1') then
            fpg_ocr0_pps_offs_int <= wrdata_reg(3 downto 0);
            fpg_ocr0_fine_int <= wrdata_reg(8 downto 4);
            fpg_ocr0_pol_int <= wrdata_reg(9);
            fpg_ocr0_mask_int <= wrdata_reg(17 downto 10);
            fpg_ocr0_cont_int <= wrdata_reg(18);
            fpg_ocr0_trig_sel_int <= wrdata_reg(19);
          end if;
          rddata_reg(3 downto 0) <= fpg_ocr0_pps_offs_int;
          rddata_reg(8 downto 4) <= fpg_ocr0_fine_int;
          rddata_reg(9) <= fpg_ocr0_pol_int;
          rddata_reg(17 downto 10) <= fpg_ocr0_mask_int;
          rddata_reg(18) <= fpg_ocr0_cont_int;
          rddata_reg(19) <= fpg_ocr0_trig_sel_int;
          rddata_reg(20) <= 'X';
          rddata_reg(21) <= 'X';
          rddata_reg(22) <= 'X';
          rddata_reg(23) <= 'X';
          rddata_reg(24) <= 'X';
          rddata_reg(25) <= 'X';
          rddata_reg(26) <= 'X';
          rddata_reg(27) <= 'X';
          rddata_reg(28) <= 'X';
          rddata_reg(29) <= 'X';
          rddata_reg(30) <= 'X';
          rddata_reg(31) <= 'X';
          ack_sreg(0) <= '1';
          ack_in_progress <= '1';
        when "0010" => 
          if (slave_i.we = '1') then
            fpg_ocr1_pps_offs_int <= wrdata_reg(3 downto 0);
            fpg_ocr1_fine_int <= wrdata_reg(8 downto 4);
            fpg_ocr1_pol_int <= wrdata_reg(9);
            fpg_ocr1_mask_int <= wrdata_reg(17 downto 10);
            fpg_ocr1_cont_int <= wrdata_reg(18);
            fpg_ocr1_trig_sel_int <= wrdata_reg(19);
          end if;
          rddata_reg(3 downto 0) <= fpg_ocr1_pps_offs_int;
          rddata_reg(8 downto 4) <= fpg_ocr1_fine_int;
          rddata_reg(9) <= fpg_ocr1_pol_int;
          rddata_reg(17 downto 10) <= fpg_ocr1_mask_int;
          rddata_reg(18) <= fpg_ocr1_cont_int;
          rddata_reg(19) <= fpg_ocr1_trig_sel_int;
          rddata_reg(20) <= 'X';
          rddata_reg(21) <= 'X';
          rddata_reg(22) <= 'X';
          rddata_reg(23) <= 'X';
          rddata_reg(24) <= 'X';
          rddata_reg(25) <= 'X';
          rddata_reg(26) <= 'X';
          rddata_reg(27) <= 'X';
          rddata_reg(28) <= 'X';
          rddata_reg(29) <= 'X';
          rddata_reg(30) <= 'X';
          rddata_reg(31) <= 'X';
          ack_sreg(0) <= '1';
          ack_in_progress <= '1';
        when "0011" => 
          if (slave_i.we = '1') then
            fpg_ocr2_pps_offs_int <= wrdata_reg(3 downto 0);
            fpg_ocr2_fine_int <= wrdata_reg(8 downto 4);
            fpg_ocr2_pol_int <= wrdata_reg(9);
            fpg_ocr2_mask_int <= wrdata_reg(17 downto 10);
            fpg_ocr2_cont_int <= wrdata_reg(18);
            fpg_ocr2_trig_sel_int <= wrdata_reg(19);
          end if;
          rddata_reg(3 downto 0) <= fpg_ocr2_pps_offs_int;
          rddata_reg(8 downto 4) <= fpg_ocr2_fine_int;
          rddata_reg(9) <= fpg_ocr2_pol_int;
          rddata_reg(17 downto 10) <= fpg_ocr2_mask_int;
          rddata_reg(18) <= fpg_ocr2_cont_int;
          rddata_reg(19) <= fpg_ocr2_trig_sel_int;
          rddata_reg(20) <= 'X';
          rddata_reg(21) <= 'X';
          rddata_reg(22) <= 'X';
          rddata_reg(23) <= 'X';
          rddata_reg(24) <= 'X';
          rddata_reg(25) <= 'X';
          rddata_reg(26) <= 'X';
          rddata_reg(27) <= 'X';
          rddata_reg(28) <= 'X';
          rddata_reg(29) <= 'X';
          rddata_reg(30) <= 'X';
          rddata_reg(31) <= 'X';
          ack_sreg(0) <= '1';
          ack_in_progress <= '1';
        when "0100" => 
          if (slave_i.we = '1') then
            fpg_ocr3_pps_offs_int <= wrdata_reg(3 downto 0);
            fpg_ocr3_fine_int <= wrdata_reg(8 downto 4);
            fpg_ocr3_pol_int <= wrdata_reg(9);
            fpg_ocr3_mask_int <= wrdata_reg(17 downto 10);
            fpg_ocr3_cont_int <= wrdata_reg(18);
            fpg_ocr3_trig_sel_int <= wrdata_reg(19);
          end if;
          rddata_reg(3 downto 0) <= fpg_ocr3_pps_offs_int;
          rddata_reg(8 downto 4) <= fpg_ocr3_fine_int;
          rddata_reg(9) <= fpg_ocr3_pol_int;
          rddata_reg(17 downto 10) <= fpg_ocr3_mask_int;
          rddata_reg(18) <= fpg_ocr3_cont_int;
          rddata_reg(19) <= fpg_ocr3_trig_sel_int;
          rddata_reg(20) <= 'X';
          rddata_reg(21) <= 'X';
          rddata_reg(22) <= 'X';
          rddata_reg(23) <= 'X';
          rddata_reg(24) <= 'X';
          rddata_reg(25) <= 'X';
          rddata_reg(26) <= 'X';
          rddata_reg(27) <= 'X';
          rddata_reg(28) <= 'X';
          rddata_reg(29) <= 'X';
          rddata_reg(30) <= 'X';
          rddata_reg(31) <= 'X';
          ack_sreg(0) <= '1';
          ack_in_progress <= '1';
        when "0101" => 
          if (slave_i.we = '1') then
            fpg_ocr4_pps_offs_int <= wrdata_reg(3 downto 0);
            fpg_ocr4_fine_int <= wrdata_reg(8 downto 4);
            fpg_ocr4_pol_int <= wrdata_reg(9);
            fpg_ocr4_mask_int <= wrdata_reg(17 downto 10);
            fpg_ocr4_cont_int <= wrdata_reg(18);
            fpg_ocr4_trig_sel_int <= wrdata_reg(19);
          end if;
          rddata_reg(3 downto 0) <= fpg_ocr4_pps_offs_int;
          rddata_reg(8 downto 4) <= fpg_ocr4_fine_int;
          rddata_reg(9) <= fpg_ocr4_pol_int;
          rddata_reg(17 downto 10) <= fpg_ocr4_mask_int;
          rddata_reg(18) <= fpg_ocr4_cont_int;
          rddata_reg(19) <= fpg_ocr4_trig_sel_int;
          rddata_reg(20) <= 'X';
          rddata_reg(21) <= 'X';
          rddata_reg(22) <= 'X';
          rddata_reg(23) <= 'X';
          rddata_reg(24) <= 'X';
          rddata_reg(25) <= 'X';
          rddata_reg(26) <= 'X';
          rddata_reg(27) <= 'X';
          rddata_reg(28) <= 'X';
          rddata_reg(29) <= 'X';
          rddata_reg(30) <= 'X';
          rddata_reg(31) <= 'X';
          ack_sreg(0) <= '1';
          ack_in_progress <= '1';
        when "0110" => 
          if (slave_i.we = '1') then
            fpg_ocr5_pps_offs_int <= wrdata_reg(3 downto 0);
            fpg_ocr5_fine_int <= wrdata_reg(8 downto 4);
            fpg_ocr5_pol_int <= wrdata_reg(9);
            fpg_ocr5_mask_int <= wrdata_reg(17 downto 10);
            fpg_ocr5_cont_int <= wrdata_reg(18);
            fpg_ocr5_trig_sel_int <= wrdata_reg(19);
          end if;
          rddata_reg(3 downto 0) <= fpg_ocr5_pps_offs_int;
          rddata_reg(8 downto 4) <= fpg_ocr5_fine_int;
          rddata_reg(9) <= fpg_ocr5_pol_int;
          rddata_reg(17 downto 10) <= fpg_ocr5_mask_int;
          rddata_reg(18) <= fpg_ocr5_cont_int;
          rddata_reg(19) <= fpg_ocr5_trig_sel_int;
          rddata_reg(20) <= 'X';
          rddata_reg(21) <= 'X';
          rddata_reg(22) <= 'X';
          rddata_reg(23) <= 'X';
          rddata_reg(24) <= 'X';
          rddata_reg(25) <= 'X';
          rddata_reg(26) <= 'X';
          rddata_reg(27) <= 'X';
          rddata_reg(28) <= 'X';
          rddata_reg(29) <= 'X';
          rddata_reg(30) <= 'X';
          rddata_reg(31) <= 'X';
          ack_sreg(0) <= '1';
          ack_in_progress <= '1';
        when "0111" => 
          if (slave_i.we = '1') then
            fpg_ocr6_pps_offs_int <= wrdata_reg(3 downto 0);
            fpg_ocr6_fine_int <= wrdata_reg(8 downto 4);
            fpg_ocr6_pol_int <= wrdata_reg(9);
            fpg_ocr6_mask_int <= wrdata_reg(17 downto 10);
            fpg_ocr6_cont_int <= wrdata_reg(18);
            fpg_ocr6_trig_sel_int <= wrdata_reg(19);
          end if;
          rddata_reg(3 downto 0) <= fpg_ocr6_pps_offs_int;
          rddata_reg(8 downto 4) <= fpg_ocr6_fine_int;
          rddata_reg(9) <= fpg_ocr6_pol_int;
          rddata_reg(17 downto 10) <= fpg_ocr6_mask_int;
          rddata_reg(18) <= fpg_ocr6_cont_int;
          rddata_reg(19) <= fpg_ocr6_trig_sel_int;
          rddata_reg(20) <= 'X';
          rddata_reg(21) <= 'X';
          rddata_reg(22) <= 'X';
          rddata_reg(23) <= 'X';
          rddata_reg(24) <= 'X';
          rddata_reg(25) <= 'X';
          rddata_reg(26) <= 'X';
          rddata_reg(27) <= 'X';
          rddata_reg(28) <= 'X';
          rddata_reg(29) <= 'X';
          rddata_reg(30) <= 'X';
          rddata_reg(31) <= 'X';
          ack_sreg(0) <= '1';
          ack_in_progress <= '1';
        when "1000" => 
          if (slave_i.we = '1') then
            fpg_ocr7_pps_offs_int <= wrdata_reg(3 downto 0);
            fpg_ocr7_fine_int <= wrdata_reg(8 downto 4);
            fpg_ocr7_pol_int <= wrdata_reg(9);
            fpg_ocr7_mask_int <= wrdata_reg(17 downto 10);
            fpg_ocr7_cont_int <= wrdata_reg(18);
            fpg_ocr7_trig_sel_int <= wrdata_reg(19);
          end if;
          rddata_reg(3 downto 0) <= fpg_ocr7_pps_offs_int;
          rddata_reg(8 downto 4) <= fpg_ocr7_fine_int;
          rddata_reg(9) <= fpg_ocr7_pol_int;
          rddata_reg(17 downto 10) <= fpg_ocr7_mask_int;
          rddata_reg(18) <= fpg_ocr7_cont_int;
          rddata_reg(19) <= fpg_ocr7_trig_sel_int;
          rddata_reg(20) <= 'X';
          rddata_reg(21) <= 'X';
          rddata_reg(22) <= 'X';
          rddata_reg(23) <= 'X';
          rddata_reg(24) <= 'X';
          rddata_reg(25) <= 'X';
          rddata_reg(26) <= 'X';
          rddata_reg(27) <= 'X';
          rddata_reg(28) <= 'X';
          rddata_reg(29) <= 'X';
          rddata_reg(30) <= 'X';
          rddata_reg(31) <= 'X';
          ack_sreg(0) <= '1';
          ack_in_progress <= '1';
        when "1001" => 
          if (slave_i.we = '1') then
            fpg_odelay_calib_rst_idelayctrl_int <= wrdata_reg(0);
            fpg_odelay_calib_rst_odelay_int <= wrdata_reg(1);
            fpg_odelay_calib_rst_oserdes_int <= wrdata_reg(2);
            fpg_odelay_calib_value_int <= wrdata_reg(12 downto 4);
            fpg_odelay_calib_value_swb <= '1';
            fpg_odelay_calib_value_swb_delay <= '1';
            fpg_odelay_calib_value_update_int <= wrdata_reg(13);
            fpg_odelay_calib_value_update_int_delay <= wrdata_reg(13);
            fpg_odelay_calib_bitslip_int <= wrdata_reg(15 downto 14);
            fpg_odelay_calib_bitslip_swb <= '1';
            fpg_odelay_calib_bitslip_swb_delay <= '1';
            fpg_odelay_calib_en_vtc_int <= wrdata_reg(16);
            fpg_odelay_calib_cal_latch_int <= wrdata_reg(17);
            fpg_odelay_calib_cal_latch_int_delay <= wrdata_reg(17);
          end if;
          rddata_reg(0) <= fpg_odelay_calib_rst_idelayctrl_int;
          rddata_reg(1) <= fpg_odelay_calib_rst_odelay_int;
          rddata_reg(2) <= fpg_odelay_calib_rst_oserdes_int;
          rddata_reg(3) <= fpg_odelay_calib_rdy_sync1;
          rddata_reg(12 downto 4) <= fpg_odelay_calib_value_int;
          rddata_reg(13) <= '0';
          rddata_reg(15 downto 14) <= fpg_odelay_calib_bitslip_int;
          rddata_reg(16) <= fpg_odelay_calib_en_vtc_int;
          rddata_reg(17) <= '0';
          if (slave_i.we = '0') then
            fpg_odelay_calib_taps_lwb <= '1';
            fpg_odelay_calib_taps_lwb_delay <= '1';
            fpg_odelay_calib_taps_lwb_in_progress <= '1';
          end if;
          rddata_reg(27) <= 'X';
          rddata_reg(28) <= 'X';
          rddata_reg(29) <= 'X';
          rddata_reg(30) <= 'X';
          rddata_reg(31) <= 'X';
          ack_sreg(5) <= '1';
          ack_in_progress <= '1';
        when others =>
-- prevent the slave from hanging the bus on invalid address
          ack_in_progress <= '1';
          ack_sreg(0) <= '1';
        end case;
      end if;
    end if;
  end if;
end process;


-- Drive the data output bus
slave_o.dat <= rddata_reg;
-- Trigger Sync Pulse 0
process (clk_sys_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_csr_trig0_dly0 <= '0';
    regs_o.csr_trig0_o <= '0';
  elsif rising_edge(clk_sys_i) then
    fpg_csr_trig0_dly0 <= fpg_csr_trig0_int;
    regs_o.csr_trig0_o <= fpg_csr_trig0_int and (not fpg_csr_trig0_dly0);
  end if;
end process;


-- Trigger Sync Pulse 1
process (clk_sys_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_csr_trig1_dly0 <= '0';
    regs_o.csr_trig1_o <= '0';
  elsif rising_edge(clk_sys_i) then
    fpg_csr_trig1_dly0 <= fpg_csr_trig1_int;
    regs_o.csr_trig1_o <= fpg_csr_trig1_int and (not fpg_csr_trig1_dly0);
  end if;
end process;


-- Trigger Sync Pulse 2
process (clk_sys_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_csr_trig2_dly0 <= '0';
    regs_o.csr_trig2_o <= '0';
  elsif rising_edge(clk_sys_i) then
    fpg_csr_trig2_dly0 <= fpg_csr_trig2_int;
    regs_o.csr_trig2_o <= fpg_csr_trig2_int and (not fpg_csr_trig2_dly0);
  end if;
end process;


-- Trigger Sync Pulse 3
process (clk_sys_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_csr_trig3_dly0 <= '0';
    regs_o.csr_trig3_o <= '0';
  elsif rising_edge(clk_sys_i) then
    fpg_csr_trig3_dly0 <= fpg_csr_trig3_int;
    regs_o.csr_trig3_o <= fpg_csr_trig3_int and (not fpg_csr_trig3_dly0);
  end if;
end process;


-- Trigger Sync Pulse 4
process (clk_sys_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_csr_trig4_dly0 <= '0';
    regs_o.csr_trig4_o <= '0';
  elsif rising_edge(clk_sys_i) then
    fpg_csr_trig4_dly0 <= fpg_csr_trig4_int;
    regs_o.csr_trig4_o <= fpg_csr_trig4_int and (not fpg_csr_trig4_dly0);
  end if;
end process;


-- Trigger Sync Pulse 5
process (clk_sys_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_csr_trig5_dly0 <= '0';
    regs_o.csr_trig5_o <= '0';
  elsif rising_edge(clk_sys_i) then
    fpg_csr_trig5_dly0 <= fpg_csr_trig5_int;
    regs_o.csr_trig5_o <= fpg_csr_trig5_int and (not fpg_csr_trig5_dly0);
  end if;
end process;


-- Trigger Sync Pulse 6
process (clk_sys_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_csr_trig6_dly0 <= '0';
    regs_o.csr_trig6_o <= '0';
  elsif rising_edge(clk_sys_i) then
    fpg_csr_trig6_dly0 <= fpg_csr_trig6_int;
    regs_o.csr_trig6_o <= fpg_csr_trig6_int and (not fpg_csr_trig6_dly0);
  end if;
end process;


-- Trigger Sync Pulse 7
process (clk_sys_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_csr_trig7_dly0 <= '0';
    regs_o.csr_trig7_o <= '0';
  elsif rising_edge(clk_sys_i) then
    fpg_csr_trig7_dly0 <= fpg_csr_trig7_int;
    regs_o.csr_trig7_o <= fpg_csr_trig7_int and (not fpg_csr_trig7_dly0);
  end if;
end process;


-- Immediately Force Sync Pulse 0
process (clk_sys_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_csr_force0_dly0 <= '0';
    regs_o.csr_force0_o <= '0';
  elsif rising_edge(clk_sys_i) then
    fpg_csr_force0_dly0 <= fpg_csr_force0_int;
    regs_o.csr_force0_o <= fpg_csr_force0_int and (not fpg_csr_force0_dly0);
  end if;
end process;


-- Immediately Force Sync Pulse 1
process (clk_sys_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_csr_force1_dly0 <= '0';
    regs_o.csr_force1_o <= '0';
  elsif rising_edge(clk_sys_i) then
    fpg_csr_force1_dly0 <= fpg_csr_force1_int;
    regs_o.csr_force1_o <= fpg_csr_force1_int and (not fpg_csr_force1_dly0);
  end if;
end process;


-- Immediately Force Sync Pulse 2
process (clk_sys_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_csr_force2_dly0 <= '0';
    regs_o.csr_force2_o <= '0';
  elsif rising_edge(clk_sys_i) then
    fpg_csr_force2_dly0 <= fpg_csr_force2_int;
    regs_o.csr_force2_o <= fpg_csr_force2_int and (not fpg_csr_force2_dly0);
  end if;
end process;


-- Immediately Force Sync Pulse 3
process (clk_sys_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_csr_force3_dly0 <= '0';
    regs_o.csr_force3_o <= '0';
  elsif rising_edge(clk_sys_i) then
    fpg_csr_force3_dly0 <= fpg_csr_force3_int;
    regs_o.csr_force3_o <= fpg_csr_force3_int and (not fpg_csr_force3_dly0);
  end if;
end process;


-- Immediately Force Sync Pulse 4
process (clk_sys_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_csr_force4_dly0 <= '0';
    regs_o.csr_force4_o <= '0';
  elsif rising_edge(clk_sys_i) then
    fpg_csr_force4_dly0 <= fpg_csr_force4_int;
    regs_o.csr_force4_o <= fpg_csr_force4_int and (not fpg_csr_force4_dly0);
  end if;
end process;


-- Immediately Force Sync Pulse 5
process (clk_sys_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_csr_force5_dly0 <= '0';
    regs_o.csr_force5_o <= '0';
  elsif rising_edge(clk_sys_i) then
    fpg_csr_force5_dly0 <= fpg_csr_force5_int;
    regs_o.csr_force5_o <= fpg_csr_force5_int and (not fpg_csr_force5_dly0);
  end if;
end process;


-- Sync Pulse Ready
-- asynchronous std_logic_vector register : Sync Pulse Ready (type RO/WO, clk_ref_i <-> clk_sys_i)
process (clk_ref_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_csr_ready_lwb_s0 <= '0';
    fpg_csr_ready_lwb_s1 <= '0';
    fpg_csr_ready_lwb_s2 <= '0';
    fpg_csr_ready_int <= "000000";
  elsif rising_edge(clk_ref_i) then
    fpg_csr_ready_lwb_s0 <= fpg_csr_ready_lwb;
    fpg_csr_ready_lwb_s1 <= fpg_csr_ready_lwb_s0;
    fpg_csr_ready_lwb_s2 <= fpg_csr_ready_lwb_s1;
    if ((fpg_csr_ready_lwb_s1 = '1') and (fpg_csr_ready_lwb_s2 = '0')) then
      fpg_csr_ready_int <= regs_i.csr_ready_i;
    end if;
  end if;
end process;


-- PLL Reset
regs_o.csr_pll_rst_o <= fpg_csr_pll_rst_int;
-- WR PPS offset
regs_o.ocr0_pps_offs_o <= fpg_ocr0_pps_offs_int;
-- Fine delay adjust
regs_o.ocr0_fine_o <= fpg_ocr0_fine_int;
-- Polarity
regs_o.ocr0_pol_o <= fpg_ocr0_pol_int;
-- Serdes Bitmask
regs_o.ocr0_mask_o <= fpg_ocr0_mask_int;
-- Continuous mode select
regs_o.ocr0_cont_o <= fpg_ocr0_cont_int;
-- Trigger select
regs_o.ocr0_trig_sel_o <= fpg_ocr0_trig_sel_int;
-- WR PPS offset
regs_o.ocr1_pps_offs_o <= fpg_ocr1_pps_offs_int;
-- Fine delay adjust
regs_o.ocr1_fine_o <= fpg_ocr1_fine_int;
-- Polarity
regs_o.ocr1_pol_o <= fpg_ocr1_pol_int;
-- Serdes Bitmask
regs_o.ocr1_mask_o <= fpg_ocr1_mask_int;
-- Continuous mode select
regs_o.ocr1_cont_o <= fpg_ocr1_cont_int;
-- Trigger select
regs_o.ocr1_trig_sel_o <= fpg_ocr1_trig_sel_int;
-- WR PPS offset
regs_o.ocr2_pps_offs_o <= fpg_ocr2_pps_offs_int;
-- Fine delay adjust
regs_o.ocr2_fine_o <= fpg_ocr2_fine_int;
-- Polarity
regs_o.ocr2_pol_o <= fpg_ocr2_pol_int;
-- Serdes Bitmask
regs_o.ocr2_mask_o <= fpg_ocr2_mask_int;
-- Continuous mode select
regs_o.ocr2_cont_o <= fpg_ocr2_cont_int;
-- Trigger select
regs_o.ocr2_trig_sel_o <= fpg_ocr2_trig_sel_int;
-- WR PPS offset
regs_o.ocr3_pps_offs_o <= fpg_ocr3_pps_offs_int;
-- Fine delay adjust
regs_o.ocr3_fine_o <= fpg_ocr3_fine_int;
-- Polarity
regs_o.ocr3_pol_o <= fpg_ocr3_pol_int;
-- Serdes Bitmask
regs_o.ocr3_mask_o <= fpg_ocr3_mask_int;
-- Continuous mode select
regs_o.ocr3_cont_o <= fpg_ocr3_cont_int;
-- Trigger select
regs_o.ocr3_trig_sel_o <= fpg_ocr3_trig_sel_int;
-- WR PPS offset
regs_o.ocr4_pps_offs_o <= fpg_ocr4_pps_offs_int;
-- Fine delay adjust
regs_o.ocr4_fine_o <= fpg_ocr4_fine_int;
-- Polarity
regs_o.ocr4_pol_o <= fpg_ocr4_pol_int;
-- Serdes Bitmask
regs_o.ocr4_mask_o <= fpg_ocr4_mask_int;
-- Continuous mode select
regs_o.ocr4_cont_o <= fpg_ocr4_cont_int;
-- Trigger select
regs_o.ocr4_trig_sel_o <= fpg_ocr4_trig_sel_int;
-- WR PPS offset
regs_o.ocr5_pps_offs_o <= fpg_ocr5_pps_offs_int;
-- Fine delay adjust
regs_o.ocr5_fine_o <= fpg_ocr5_fine_int;
-- Polarity
regs_o.ocr5_pol_o <= fpg_ocr5_pol_int;
-- Serdes Bitmask
regs_o.ocr5_mask_o <= fpg_ocr5_mask_int;
-- Continuous mode select
regs_o.ocr5_cont_o <= fpg_ocr5_cont_int;
-- Trigger select
regs_o.ocr5_trig_sel_o <= fpg_ocr5_trig_sel_int;
-- WR PPS offset
regs_o.ocr6_pps_offs_o <= fpg_ocr6_pps_offs_int;
-- Fine delay adjust
regs_o.ocr6_fine_o <= fpg_ocr6_fine_int;
-- Polarity
regs_o.ocr6_pol_o <= fpg_ocr6_pol_int;
-- Serdes Bitmask
regs_o.ocr6_mask_o <= fpg_ocr6_mask_int;
-- Continuous mode select
regs_o.ocr6_cont_o <= fpg_ocr6_cont_int;
-- Trigger select
regs_o.ocr6_trig_sel_o <= fpg_ocr6_trig_sel_int;
-- WR PPS offset
regs_o.ocr7_pps_offs_o <= fpg_ocr7_pps_offs_int;
-- Fine delay adjust
regs_o.ocr7_fine_o <= fpg_ocr7_fine_int;
-- Polarity
regs_o.ocr7_pol_o <= fpg_ocr7_pol_int;
-- Serdes Bitmask
regs_o.ocr7_mask_o <= fpg_ocr7_mask_int;
-- Continuous mode select
regs_o.ocr7_cont_o <= fpg_ocr7_cont_int;
-- Trigger select
regs_o.ocr7_trig_sel_o <= fpg_ocr7_trig_sel_int;
-- Reset Output IDELAYCTRL
-- synchronizer chain for field : Reset Output IDELAYCTRL (type RW/RO, clk_sys_i <-> clk_odelay_i)
process (clk_odelay_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    regs_o.odelay_calib_rst_idelayctrl_o <= '0';
    fpg_odelay_calib_rst_idelayctrl_sync0 <= '0';
    fpg_odelay_calib_rst_idelayctrl_sync1 <= '0';
  elsif rising_edge(clk_odelay_i) then
    fpg_odelay_calib_rst_idelayctrl_sync0 <= fpg_odelay_calib_rst_idelayctrl_int;
    fpg_odelay_calib_rst_idelayctrl_sync1 <= fpg_odelay_calib_rst_idelayctrl_sync0;
    regs_o.odelay_calib_rst_idelayctrl_o <= fpg_odelay_calib_rst_idelayctrl_sync1;
  end if;
end process;


-- Reset Output ODELAY
-- synchronizer chain for field : Reset Output ODELAY (type RW/RO, clk_sys_i <-> clk_odelay_i)
process (clk_odelay_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    regs_o.odelay_calib_rst_odelay_o <= '0';
    fpg_odelay_calib_rst_odelay_sync0 <= '0';
    fpg_odelay_calib_rst_odelay_sync1 <= '0';
  elsif rising_edge(clk_odelay_i) then
    fpg_odelay_calib_rst_odelay_sync0 <= fpg_odelay_calib_rst_odelay_int;
    fpg_odelay_calib_rst_odelay_sync1 <= fpg_odelay_calib_rst_odelay_sync0;
    regs_o.odelay_calib_rst_odelay_o <= fpg_odelay_calib_rst_odelay_sync1;
  end if;
end process;


-- Reset Output OSERDES
-- synchronizer chain for field : Reset Output OSERDES (type RW/RO, clk_sys_i <-> clk_odelay_i)
process (clk_odelay_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    regs_o.odelay_calib_rst_oserdes_o <= '0';
    fpg_odelay_calib_rst_oserdes_sync0 <= '0';
    fpg_odelay_calib_rst_oserdes_sync1 <= '0';
  elsif rising_edge(clk_odelay_i) then
    fpg_odelay_calib_rst_oserdes_sync0 <= fpg_odelay_calib_rst_oserdes_int;
    fpg_odelay_calib_rst_oserdes_sync1 <= fpg_odelay_calib_rst_oserdes_sync0;
    regs_o.odelay_calib_rst_oserdes_o <= fpg_odelay_calib_rst_oserdes_sync1;
  end if;
end process;


-- Output Delay Ready
-- synchronizer chain for field : Output Delay Ready (type RO/WO, clk_odelay_i -> clk_sys_i)
process (clk_odelay_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_odelay_calib_rdy_sync0 <= '0';
    fpg_odelay_calib_rdy_sync1 <= '0';
  elsif rising_edge(clk_odelay_i) then
    fpg_odelay_calib_rdy_sync0 <= regs_i.odelay_calib_rdy_i;
    fpg_odelay_calib_rdy_sync1 <= fpg_odelay_calib_rdy_sync0;
  end if;
end process;


-- Output Delay Value
-- asynchronous std_logic_vector register : Output Delay Value (type RW/RO, clk_odelay_i <-> clk_sys_i)
process (clk_odelay_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_odelay_calib_value_swb_s0 <= '0';
    fpg_odelay_calib_value_swb_s1 <= '0';
    fpg_odelay_calib_value_swb_s2 <= '0';
    regs_o.odelay_calib_value_o <= "000000000";
  elsif rising_edge(clk_odelay_i) then
    fpg_odelay_calib_value_swb_s0 <= fpg_odelay_calib_value_swb;
    fpg_odelay_calib_value_swb_s1 <= fpg_odelay_calib_value_swb_s0;
    fpg_odelay_calib_value_swb_s2 <= fpg_odelay_calib_value_swb_s1;
    if ((fpg_odelay_calib_value_swb_s2 = '0') and (fpg_odelay_calib_value_swb_s1 = '1')) then
      regs_o.odelay_calib_value_o <= fpg_odelay_calib_value_int;
    end if;
  end if;
end process;


-- Delay value update
process (clk_odelay_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    regs_o.odelay_calib_value_update_o <= '0';
    fpg_odelay_calib_value_update_sync0 <= '0';
    fpg_odelay_calib_value_update_sync1 <= '0';
    fpg_odelay_calib_value_update_sync2 <= '0';
  elsif rising_edge(clk_odelay_i) then
    fpg_odelay_calib_value_update_sync0 <= fpg_odelay_calib_value_update_int;
    fpg_odelay_calib_value_update_sync1 <= fpg_odelay_calib_value_update_sync0;
    fpg_odelay_calib_value_update_sync2 <= fpg_odelay_calib_value_update_sync1;
    regs_o.odelay_calib_value_update_o <= fpg_odelay_calib_value_update_sync2 and (not fpg_odelay_calib_value_update_sync1);
  end if;
end process;


-- Serdes Bitslip
-- asynchronous std_logic_vector register : Serdes Bitslip (type RW/RO, clk_odelay_i <-> clk_sys_i)
process (clk_odelay_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_odelay_calib_bitslip_swb_s0 <= '0';
    fpg_odelay_calib_bitslip_swb_s1 <= '0';
    fpg_odelay_calib_bitslip_swb_s2 <= '0';
    regs_o.odelay_calib_bitslip_o <= "00";
  elsif rising_edge(clk_odelay_i) then
    fpg_odelay_calib_bitslip_swb_s0 <= fpg_odelay_calib_bitslip_swb;
    fpg_odelay_calib_bitslip_swb_s1 <= fpg_odelay_calib_bitslip_swb_s0;
    fpg_odelay_calib_bitslip_swb_s2 <= fpg_odelay_calib_bitslip_swb_s1;
    if ((fpg_odelay_calib_bitslip_swb_s2 = '0') and (fpg_odelay_calib_bitslip_swb_s1 = '1')) then
      regs_o.odelay_calib_bitslip_o <= fpg_odelay_calib_bitslip_int;
    end if;
  end if;
end process;


-- Enable VT compensation
-- synchronizer chain for field : Enable VT compensation (type RW/RO, clk_sys_i <-> clk_odelay_i)
process (clk_odelay_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    regs_o.odelay_calib_en_vtc_o <= '0';
    fpg_odelay_calib_en_vtc_sync0 <= '0';
    fpg_odelay_calib_en_vtc_sync1 <= '0';
  elsif rising_edge(clk_odelay_i) then
    fpg_odelay_calib_en_vtc_sync0 <= fpg_odelay_calib_en_vtc_int;
    fpg_odelay_calib_en_vtc_sync1 <= fpg_odelay_calib_en_vtc_sync0;
    regs_o.odelay_calib_en_vtc_o <= fpg_odelay_calib_en_vtc_sync1;
  end if;
end process;


-- Latch calibration taps
process (clk_odelay_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    regs_o.odelay_calib_cal_latch_o <= '0';
    fpg_odelay_calib_cal_latch_sync0 <= '0';
    fpg_odelay_calib_cal_latch_sync1 <= '0';
    fpg_odelay_calib_cal_latch_sync2 <= '0';
  elsif rising_edge(clk_odelay_i) then
    fpg_odelay_calib_cal_latch_sync0 <= fpg_odelay_calib_cal_latch_int;
    fpg_odelay_calib_cal_latch_sync1 <= fpg_odelay_calib_cal_latch_sync0;
    fpg_odelay_calib_cal_latch_sync2 <= fpg_odelay_calib_cal_latch_sync1;
    regs_o.odelay_calib_cal_latch_o <= fpg_odelay_calib_cal_latch_sync2 and (not fpg_odelay_calib_cal_latch_sync1);
  end if;
end process;


-- n Taps
-- asynchronous std_logic_vector register : n Taps (type RO/WO, clk_odelay_i <-> clk_sys_i)
process (clk_odelay_i, rst_n_i)
begin
  if (rst_n_i = '0') then 
    fpg_odelay_calib_taps_lwb_s0 <= '0';
    fpg_odelay_calib_taps_lwb_s1 <= '0';
    fpg_odelay_calib_taps_lwb_s2 <= '0';
    fpg_odelay_calib_taps_int <= "000000000";
  elsif rising_edge(clk_odelay_i) then
    fpg_odelay_calib_taps_lwb_s0 <= fpg_odelay_calib_taps_lwb;
    fpg_odelay_calib_taps_lwb_s1 <= fpg_odelay_calib_taps_lwb_s0;
    fpg_odelay_calib_taps_lwb_s2 <= fpg_odelay_calib_taps_lwb_s1;
    if ((fpg_odelay_calib_taps_lwb_s1 = '1') and (fpg_odelay_calib_taps_lwb_s2 = '0')) then
      fpg_odelay_calib_taps_int <= regs_i.odelay_calib_taps_i;
    end if;
  end if;
end process;


rwaddr_reg <= slave_i.adr(5 downto 2);
slave_o.stall <= (not ack_sreg(0)) and (slave_i.stb and slave_i.cyc);
slave_o.err <= '0';
slave_o.rty <= '0';
-- ACK signal generation. Just pass the LSB of ACK counter.
slave_o.ack <= ack_sreg(0);
end syn;
